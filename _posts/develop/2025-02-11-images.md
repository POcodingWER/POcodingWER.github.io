---
layout: post
title: "[DEVELOP] ì›¹ì—ì„œ ì‚¬ìš©í•˜ëŠ” ì´ë¯¸ì§€ ì•Œê³  ì‚¬ìš©í•˜ê¸° (Images)"

subtitle: "ì˜ˆì œë¡œ ë³´ëŠ” ì´ë¯¸ì§€ ì‚¬ìš©ë²•"

date: 2025-02-11 08:35:59
# lastmod: 2024-08-14 10:10:00
author: "lim.Chuck"

# header-style: text

catalog: true
header-mask: 0.4
header-img: "img/post/2025/02/images.png"
#
# sitemap:
#   changefreq: daily #ìŠ¤í¬ë© ì£¼ê¸°  daily | weekly | monthly
#   priority: 1.0  # ìŠ¤í¬ë© ìš°ì„ ìˆœìœ„
# hidden: true
categories:
  - DEVELOP
tags:
  - Images
  - ì´ë¯¸ì§€ í¬ë§·
  - ë°˜ì‘í˜• ì´ë¯¸ì§€
  - ì„±ëŠ¥ ìµœì í™”
  - ì••ì¶• ë° ìµœì í™”
  - í”„ë ˆì„ì›Œí¬
  - CMS
---

![alt text](/img/post/2025/02/images.png)

## ğŸ“š 1ì¥: ì´ë¯¸ì§€ í¬ë§· ì´í•´í•˜ê¸°

#### 1ï¸âƒ£ ì£¼ìš” ì´ë¯¸ì§€ í¬ë§· ë¹„êµ

```html:example/image-formats.html
<!-- ê° í¬ë§·ë³„ ìµœì  ì‚¬ìš© ì‚¬ë¡€ -->
<div class="image-examples">
  <!-- JPEG: ì‚¬ì§„ì´ë‚˜ ë³µì¡í•œ ì´ë¯¸ì§€ -->
  <img
    src="photo.jpg"
    alt="í’ê²½ ì‚¬ì§„"
    loading="lazy"
  >

  <!-- PNG: íˆ¬ëª…ë„ê°€ í•„ìš”í•œ ë¡œê³  -->
  <img
    src="logo.png"
    alt="íšŒì‚¬ ë¡œê³ "
    width="200"
    height="100"
  >

  <!-- WebP: ìµœì‹  ë¸Œë¼ìš°ì € ì§€ì› -->
  <picture>
    <source
      srcset="image.webp"
      type="image/webp">
    <img
      src="image.jpg"
      alt="ëŒ€ì²´ ì´ë¯¸ì§€"
    >
  </picture>

  <!-- AVIF: ìµœê³ ì˜ ì••ì¶•ë¥  -->
  <picture>
    <source
      srcset="photo.avif"
      type="image/avif">
    <source
      srcset="photo.webp"
      type="image/webp">
    <img
      src="photo.jpg"
      alt="ëŒ€ì²´ ì´ë¯¸ì§€"
    >
  </picture>
</div>
```

#### 2ï¸âƒ£ í¬ë§·ë³„ íŠ¹ì§•

```js
const imageFormats = {
  jpeg: {
    pros: ["ì‘ì€ íŒŒì¼ í¬ê¸°", "ë„“ì€ ë¸Œë¼ìš°ì € ì§€ì›", "ì‚¬ì§„ì— ì í•©"],
    cons: ["íˆ¬ëª…ë„ ì§€ì› ì•ˆ í•¨", "ì†ì‹¤ ì••ì¶•ìœ¼ë¡œ ì¸í•œ í’ˆì§ˆ ì €í•˜"],
    bestFor: "ì‚¬ì§„, ë³µì¡í•œ ì´ë¯¸ì§€",
  },

  png: {
    pros: ["ë¬´ì†ì‹¤ ì••ì¶•", "íˆ¬ëª…ë„ ì§€ì›", "ì„ ëª…í•œ í…ìŠ¤íŠ¸ì™€ ë¼ì¸"],
    cons: ["í° íŒŒì¼ í¬ê¸°", "ì‚¬ì§„ì—ëŠ” ë¹„íš¨ìœ¨ì "],
    bestFor: "ë¡œê³ , ì•„ì´ì½˜, ìŠ¤í¬ë¦°ìƒ·",
  },

  webp: {
    pros: ["JPEGë³´ë‹¤ ë‚˜ì€ ì••ì¶•ë¥ ", "íˆ¬ëª…ë„ ì§€ì›", "ì• ë‹ˆë©”ì´ì…˜ ì§€ì›"],
    cons: ["ì¼ë¶€ êµ¬í˜• ë¸Œë¼ìš°ì € ë¯¸ì§€ì›"],
    bestFor: "ì›¹ ìµœì í™”ê°€ í•„ìš”í•œ ëª¨ë“  ì´ë¯¸ì§€",
  },

  avif: {
    pros: ["ìµœê³ ì˜ ì••ì¶•ë¥ ", "ë›°ì–´ë‚œ í’ˆì§ˆ", "HDR ì§€ì›"],
    cons: ["ì œí•œì ì¸ ë¸Œë¼ìš°ì € ì§€ì›", "ì¸ì½”ë”© ì‹œê°„ì´ ê¹€"],
    bestFor: "ìµœì‹  ë¸Œë¼ìš°ì € ì‚¬ìš©ìë¥¼ ìœ„í•œ ìµœì í™”",
  },
};
```

#### 3ï¸âƒ£ ì´ë¯¸ì§€ ë³€í™˜ ì˜ˆì œ

```js
class ImageConverter {
  // ì´ë¯¸ì§€ í¬ë§· ë³€í™˜
  async convertImage(file, format) {
    try {
      const image = await loadImage(file);

      switch (format) {
        case "webp":
          return await this.toWebP(image, {
            quality: 0.8,
            lossless: false,
          });

        case "avif":
          return await this.toAVIF(image, {
            quality: 0.7,
            speed: 5,
          });

        case "jpeg":
          return await this.toJPEG(image, {
            quality: 0.85,
            progressive: true,
          });
      }
    } catch (error) {
      console.error("ì´ë¯¸ì§€ ë³€í™˜ ì‹¤íŒ¨:", error);
      throw error;
    }
  }

  // ìµœì ì˜ í¬ë§· ì¶”ì²œ
  recommendFormat(imageType, requirements) {
    if (requirements.transparency) {
      return ["webp", "png"];
    }

    if (requirements.animation) {
      return ["webp", "gif"];
    }

    if (requirements.quality === "high") {
      return ["avif", "webp", "jpeg"];
    }

    return ["jpeg"];
  }
}
```

### ğŸŒŸ 1ì¥ í•µì‹¬ í¬ì¸íŠ¸

1. **JPEG**

   - ì‚¬ì§„ì´ë‚˜ ë³µì¡í•œ ì´ë¯¸ì§€ì— ì í•©
   - ì‘ì€ íŒŒì¼ í¬ê¸°
   - íˆ¬ëª…ë„ ì§€ì› ì•ˆ í•¨

2. **PNG**

   - ë¡œê³ , ì•„ì´ì½˜ì— ì í•©
   - íˆ¬ëª…ë„ ì§€ì›
   - íŒŒì¼ í¬ê¸°ê°€ í¼

3. **WebP**

   - JPEGë³´ë‹¤ ì¢‹ì€ ì••ì¶•ë¥ 
   - íˆ¬ëª…ë„ì™€ ì• ë‹ˆë©”ì´ì…˜ ì§€ì›
   - ëŒ€ë¶€ë¶„ì˜ ìµœì‹  ë¸Œë¼ìš°ì € ì§€ì›

4. **AVIF**
   - ìµœê³ ì˜ ì••ì¶•ë¥ ê³¼ í’ˆì§ˆ
   - HDR ì§€ì›
   - ì œí•œì ì¸ ë¸Œë¼ìš°ì € ì§€ì›

## ğŸ“š 2ì¥: ë°˜ì‘í˜• ì´ë¯¸ì§€

#### 1ï¸âƒ£ srcsetê³¼ sizes ì‚¬ìš©

```html:example/responsive-images.html
<!-- ê¸°ë³¸ì ì¸ ë°˜ì‘í˜• ì´ë¯¸ì§€ -->
<img
  src="small.jpg"
  srcset="
    small.jpg 300w,
    medium.jpg 600w,
    large.jpg 900w"
  sizes="
    (max-width: 320px) 280px,
    (max-width: 640px) 580px,
    800px"
  alt="ë°˜ì‘í˜• ì´ë¯¸ì§€ ì˜ˆì œ"
  loading="lazy"
>

<!-- art directionì„ ìœ„í•œ picture ìš”ì†Œ -->
<picture>
  <!-- ëª¨ë°”ì¼ìš© ì„¸ë¡œ ì´ë¯¸ì§€ -->
  <source
    media="(max-width: 640px)"
    srcset="
      mobile.jpg 300w,
      mobile-hd.jpg 600w"
    sizes="90vw">

  <!-- ë°ìŠ¤í¬í†±ìš© ê°€ë¡œ ì´ë¯¸ì§€ -->
  <source
    media="(min-width: 641px)"
    srcset="
      desktop.jpg 800w,
      desktop-hd.jpg 1600w"
    sizes="80vw">

  <!-- í´ë°± ì´ë¯¸ì§€ -->
  <img
    src="fallback.jpg"
    alt="ë°˜ì‘í˜• ì´ë¯¸ì§€"
    loading="lazy">
</picture>
```

#### 2ï¸âƒ£ ë°˜ì‘í˜• ì´ë¯¸ì§€ í—¬í¼ í´ë˜ìŠ¤

```js
class ResponsiveImageHelper {
  constructor() {
    this.breakpoints = {
      mobile: 320,
      tablet: 768,
      desktop: 1024,
      wide: 1440,
    };
  }

  // srcset ë¬¸ìì—´ ìƒì„±
  generateSrcset(imagePath, widths) {
    return widths
      .map((width) => {
        const imageUrl = this.generateImageUrl(imagePath, width);
        return `${imageUrl} ${width}w`;
      })
      .join(", ");
  }

  // sizes ë¬¸ìì—´ ìƒì„±
  generateSizes(config) {
    return Object.entries(config)
      .map(([breakpoint, size]) => {
        if (breakpoint === "default") {
          return size;
        }
        return `(max-width: ${this.breakpoints[breakpoint]}px) ${size}`;
      })
      .join(", ");
  }

  // ì´ë¯¸ì§€ URL ìƒì„± (CDN í™œìš©)
  generateImageUrl(path, width) {
    return `https://cdn.example.com/images/${path}?width=${width}`;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const helper = new ResponsiveImageHelper();
const srcset = helper.generateSrcset("photo.jpg", [300, 600, 900]);
const sizes = helper.generateSizes({
  mobile: "90vw",
  tablet: "80vw",
  default: "70vw",
});
```

#### 3ï¸âƒ£ ì„±ëŠ¥ ìµœì í™”ëœ ì§€ì—° ë¡œë”©

```js
class LazyLoadImages {
  constructor() {
    this.images = document.querySelectorAll("img[data-src]");
    this.setupIntersectionObserver();
  }

  setupIntersectionObserver() {
    const options = {
      root: null,
      rootMargin: "50px 0px",
      threshold: 0.1,
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.loadImage(entry.target);
          observer.unobserve(entry.target);
        }
      });
    }, options);

    this.images.forEach((image) => observer.observe(image));
  }

  loadImage(image) {
    // srcsetì´ ìˆìœ¼ë©´ ë¨¼ì € ì„¤ì •
    if (image.dataset.srcset) {
      image.srcset = image.dataset.srcset;
    }

    // ê¸°ë³¸ src ì„¤ì •
    image.src = image.dataset.src;

    // ë¡œë”© ì™„ë£Œ í›„ í”Œë ˆì´ìŠ¤í™€ë” ì œê±°
    image.onload = () => {
      image.classList.remove("placeholder");
      image.classList.add("loaded");
    };
  }
}
```

#### 4ï¸âƒ£ ë°˜ì‘í˜• ë°°ê²½ ì´ë¯¸ì§€

```css
/* ë°˜ì‘í˜• ë°°ê²½ ì´ë¯¸ì§€ */
.hero-section {
  /* ê¸°ë³¸ ë°°ê²½ */
  background-image: url("mobile.jpg");
  background-size: cover;
  background-position: center;

  /* íƒœë¸”ë¦¿ */
  @media (min-width: 768px) {
    background-image: url("tablet.jpg");
  }

  /* ë°ìŠ¤í¬í†± */
  @media (min-width: 1024px) {
    background-image: url("desktop.jpg");
  }

  /* Retina ë””ìŠ¤í”Œë ˆì´ */
  @media (min-resolution: 2dppx) {
    background-image: url("desktop@2x.jpg");
  }
}

/* ì•„íŠ¸ ë””ë ‰ì…˜ì„ ìœ„í•œ ë°˜ì‘í˜• ì»¨í…Œì´ë„ˆ */
.image-container {
  position: relative;
  aspect-ratio: 16 / 9;

  @media (max-width: 767px) {
    aspect-ratio: 4 / 5;
  }
}
```

### ğŸŒŸ 2ì¥ í•µì‹¬ í¬ì¸íŠ¸

1. **srcsetê³¼ sizes**

   - ë‹¤ì–‘í•œ í¬ê¸°ì˜ ì´ë¯¸ì§€ ì œê³µ
   - ë¸Œë¼ìš°ì €ê°€ ìµœì  ì´ë¯¸ì§€ ì„ íƒ
   - ë””ë°”ì´ìŠ¤ íŠ¹ì„± ê³ ë ¤

2. **picture ìš”ì†Œ**

   - ì•„íŠ¸ ë””ë ‰ì…˜ ì§€ì›
   - ë‹¤ì–‘í•œ ì´ë¯¸ì§€ í¬ë§· ì§€ì›
   - í´ë°± ì´ë¯¸ì§€ ì œê³µ

3. **ì§€ì—° ë¡œë”©**

   - ì„±ëŠ¥ ìµœì í™”
   - ë¶ˆí•„ìš”í•œ ë‹¤ìš´ë¡œë“œ ë°©ì§€
   - ì‚¬ìš©ì ê²½í—˜ ê°œì„ 

4. **ë°˜ì‘í˜• ë°°ê²½**
   - ë¯¸ë””ì–´ ì¿¼ë¦¬ í™œìš©
   - Retina ë””ìŠ¤í”Œë ˆì´ ì§€ì›
   - ì•„íŠ¸ ë””ë ‰ì…˜ ê³ ë ¤

## ğŸ“š 3ì¥: ì´ë¯¸ì§€ ì„±ëŠ¥ ìµœì í™”

#### 1ï¸âƒ£ ì´ë¯¸ì§€ ì••ì¶• ë° ìµœì í™”

```js
class ImageOptimizer {
  constructor() {
    this.quality = {
      jpeg: 0.85, // 85% í’ˆì§ˆ
      webp: 0.8, // 80% í’ˆì§ˆ
      avif: 0.75, // 75% í’ˆì§ˆ
    };
  }

  // ì´ë¯¸ì§€ ìµœì í™” ì„¤ì •
  async optimizeImage(file) {
    const optimized = await sharp(file)
      // ì ì ˆí•œ í¬ê¸°ë¡œ ë¦¬ì‚¬ì´ì§•
      .resize({
        width: 1200,
        height: 800,
        fit: "inside",
        withoutEnlargement: true,
      })
      // ë©”íƒ€ë°ì´í„° ì œê±°
      .removeMetadata()
      // ë‹¤ì–‘í•œ í¬ë§·ìœ¼ë¡œ ë³€í™˜
      .toFormat("webp", {
        quality: 80,
        effort: 6,
      });

    return optimized;
  }

  // ì—¬ëŸ¬ í¬ê¸°ì˜ ì´ë¯¸ì§€ ìƒì„±
  async generateSizes(file) {
    const sizes = [300, 600, 900, 1200];
    const outputs = [];

    for (const size of sizes) {
      const optimized = await sharp(file)
        .resize(size)
        .toFormat("webp")
        .toBuffer();

      outputs.push({
        size,
        buffer: optimized,
      });
    }

    return outputs;
  }
}
```

#### 2ï¸âƒ£ CDN í™œìš©

```js
class ImageCDN {
  constructor() {
    this.cdnUrl = "https://cdn.example.com/images";
    this.defaultParams = {
      format: "auto", // ìë™ í¬ë§· ì„ íƒ
      quality: "auto", // ìë™ í’ˆì§ˆ ì¡°ì •
      compress: true, // ì••ì¶• í™œì„±í™”
    };
  }

  // CDN URL ìƒì„±
  generateUrl(imagePath, options = {}) {
    const params = {
      ...this.defaultParams,
      ...options,
    };

    const queryString = Object.entries(params)
      .map(([key, value]) => `${key}=${value}`)
      .join("&");

    return `${this.cdnUrl}/${imagePath}?${queryString}`;
  }

  // ë°˜ì‘í˜• ì´ë¯¸ì§€ URL ì„¸íŠ¸ ìƒì„±
  generateResponsiveSet(imagePath) {
    const widths = [300, 600, 900, 1200];

    return widths.map((width) => ({
      url: this.generateUrl(imagePath, { width }),
      width,
    }));
  }
}
```

#### 3ï¸âƒ£ ìºì‹± ì „ëµ

```js
class ImageCache {
  constructor() {
    this.cacheName = "image-cache-v1";
  }

  // ì„œë¹„ìŠ¤ ì›Œì»¤ ìºì‹±
  async cacheImage(request, response) {
    const cache = await caches.open(this.cacheName);
    await cache.put(request, response);
  }

  // ìºì‹œ ìš°ì„  ì „ëµ
  async getCachedImage(request) {
    const cache = await caches.open(this.cacheName);
    const cached = await cache.match(request);

    if (cached) {
      // ìºì‹œëœ ì´ë¯¸ì§€ ë°˜í™˜
      return cached;
    }

    // ë„¤íŠ¸ì›Œí¬ì—ì„œ ê°€ì ¸ì˜¤ê¸°
    const response = await fetch(request);
    await this.cacheImage(request, response.clone());
    return response;
  }

  // ìºì‹œ ì •ë¦¬
  async cleanOldCache() {
    const keys = await caches.keys();
    const oldCaches = keys.filter(
      (key) => key.startsWith("image-cache") && key !== this.cacheName
    );

    await Promise.all(oldCaches.map((key) => caches.delete(key)));
  }
}
```

#### 4ï¸âƒ£ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```js
class ImagePerformanceMonitor {
  constructor() {
    this.metrics = {
      loadTime: [],
      size: [],
      cacheHits: 0,
      errors: [],
    };
  }

  // ì´ë¯¸ì§€ ë¡œë”© ì„±ëŠ¥ ì¸¡ì •
  measureLoadTime(imageUrl) {
    const start = performance.now();

    return new Promise((resolve, reject) => {
      const img = new Image();

      img.onload = () => {
        const loadTime = performance.now() - start;
        this.metrics.loadTime.push({
          url: imageUrl,
          time: loadTime,
        });
        resolve(loadTime);
      };

      img.onerror = (error) => {
        this.metrics.errors.push({
          url: imageUrl,
          error,
        });
        reject(error);
      };

      img.src = imageUrl;
    });
  }

  // ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„±
  generateReport() {
    return {
      averageLoadTime: this.calculateAverageLoadTime(),
      totalErrors: this.metrics.errors.length,
      cacheEfficiency: this.calculateCacheEfficiency(),
      recommendations: this.generateRecommendations(),
    };
  }
}
```

### ğŸŒŸ 3ì¥ í•µì‹¬ í¬ì¸íŠ¸

1. **ì´ë¯¸ì§€ ìµœì í™”**

   - ì ì ˆí•œ í¬ê¸°ë¡œ ë¦¬ì‚¬ì´ì§•
   - í’ˆì§ˆ ì¡°ì •ìœ¼ë¡œ ìš©ëŸ‰ ì¤„ì´ê¸°
   - ìµœì‹  í¬ë§·(WebP, AVIF) í™œìš©

2. **CDN í™œìš©**

   - ì‚¬ìš©ìì™€ ê°€ê¹Œìš´ ì„œë²„ì—ì„œ ì „ì†¡
   - ìë™ ìµœì í™” ê¸°ëŠ¥ í™œìš©
   - ìºì‹± íš¨ê³¼ ê·¹ëŒ€í™”

3. **ìºì‹± ì „ëµ**

   - ë¸Œë¼ìš°ì € ìºì‹œ í™œìš©
   - ì„œë¹„ìŠ¤ ì›Œì»¤ ìºì‹±
   - íš¨ìœ¨ì ì¸ ìºì‹œ ê´€ë¦¬

4. **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**
   - ë¡œë”© ì‹œê°„ ì¸¡ì •
   - ì—ëŸ¬ ì¶”ì 
   - ìµœì í™” ì¶”ì²œ

ë„¤! 4ì¥ "ì´ë¯¸ì§€ ì‚¬ìš©ì ê²½í—˜(UX) ìµœì í™”"ë¥¼ ì„¤ëª…í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤! ì‚¬ìš©ìì—ê²Œ ë” ë‚˜ì€ ì´ë¯¸ì§€ ê²½í—˜ì„ ì œê³µí•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³¼ê²Œìš”.

## ğŸ“š 4ì¥: ì´ë¯¸ì§€ UX ìµœì í™”

#### 1ï¸âƒ£ ë¡œë”© ìƒíƒœ ì²˜ë¦¬

```html:example/loading-states.html
<!-- ì´ë¯¸ì§€ ë¡œë”© ìŠ¤ì¼ˆë ˆí†¤ -->
<div class="image-wrapper">
  <!-- ìŠ¤ì¼ˆë ˆí†¤ UI -->
  <div class="skeleton" aria-hidden="true">
    <div class="pulse"></div>
  </div>

  <!-- ì‹¤ì œ ì´ë¯¸ì§€ -->
  <img
    src="photo.jpg"
    alt="í’ê²½ ì‚¬ì§„"
    loading="lazy"
    onload="this.classList.add('loaded')"
    onerror="this.classList.add('error')"
  >

  <!-- ì—ëŸ¬ ìƒíƒœ -->
  <div class="error-state" hidden>
    <span>ğŸ˜¢ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨</span>
    <button onclick="retryLoad()">ë‹¤ì‹œ ì‹œë„</button>
  </div>
</div>

<style>
.skeleton {
  background: #f0f0f0;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.pulse {
  animation: pulse 1.5s infinite;
}

.loaded {
  opacity: 1;
  transition: opacity 0.3s;
}

@keyframes pulse {
  0% { opacity: 0.6; }
  50% { opacity: 1; }
  100% { opacity: 0.6; }
}
</style>
```

#### 2ï¸âƒ£ ì ì§„ì  ì´ë¯¸ì§€ ë¡œë”©

```js
class ProgressiveImageLoader {
  constructor() {
    this.loadQueue = new Map();
  }

  // ì ì§„ì  ì´ë¯¸ì§€ ë¡œë”©
  loadProgressively(imageUrl, container) {
    // ì‘ì€ ë¸”ëŸ¬ëœ ì¸ë„¤ì¼ ë¨¼ì € ë¡œë“œ
    this.loadThumbnail(imageUrl, container);

    // ê³ í’ˆì§ˆ ì´ë¯¸ì§€ ë¡œë“œ
    this.loadFullImage(imageUrl, container);
  }

  async loadThumbnail(imageUrl, container) {
    const thumbnailUrl = this.getThumbnailUrl(imageUrl);
    const img = new Image();

    img.onload = () => {
      container.style.backgroundImage = `url(${thumbnailUrl})`;
      container.classList.add("blur");
    };

    img.src = thumbnailUrl;
  }

  async loadFullImage(imageUrl, container) {
    const img = new Image();

    img.onload = () => {
      container.style.backgroundImage = `url(${imageUrl})`;
      container.classList.remove("blur");
      container.classList.add("loaded");
    };

    img.src = imageUrl;
  }

  // ì¸ë„¤ì¼ URL ìƒì„± (ì‘ê³  ë¸”ëŸ¬ëœ ì´ë¯¸ì§€)
  getThumbnailUrl(imageUrl) {
    return `${imageUrl}?w=20&blur=true`;
  }
}
```

#### 3ï¸âƒ£ ì´ë¯¸ì§€ ì¤Œ ë° ê°¤ëŸ¬ë¦¬

```js
class ImageZoomViewer {
  constructor(container) {
    this.container = container;
    this.setupZoom();
  }

  setupZoom() {
    this.container.addEventListener("mousemove", (e) => {
      this.handleZoom(e);
    });

    this.container.addEventListener("mouseleave", () => {
      this.resetZoom();
    });
  }

  handleZoom(event) {
    const bounds = this.container.getBoundingClientRect();
    const x = (event.clientX - bounds.left) / bounds.width;
    const y = (event.clientY - bounds.top) / bounds.height;

    this.container.style.transformOrigin = `${x * 100}% ${y * 100}%`;
    this.container.classList.add("zoomed");
  }

  resetZoom() {
    this.container.classList.remove("zoomed");
  }
}

// ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬
class ImageGallery {
  constructor() {
    this.currentIndex = 0;
    this.setupGallery();
  }

  setupGallery() {
    this.container.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight") this.next();
      if (e.key === "ArrowLeft") this.previous();
    });
  }

  showImage(index) {
    // í˜„ì¬ ì´ë¯¸ì§€ í˜ì´ë“œ ì•„ì›ƒ
    this.fadeOut(this.currentImage);

    // ìƒˆ ì´ë¯¸ì§€ í˜ì´ë“œ ì¸
    this.fadeIn(this.images[index]);

    this.currentIndex = index;
    this.updateThumbnails();
  }
}
```

#### 4ï¸âƒ£ ì ‘ê·¼ì„±ê³¼ ëŒ€ì²´ í…ìŠ¤íŠ¸

```js
class ImageAccessibility {
  constructor() {
    this.setupAccessibility();
  }

  // ë™ì  ëŒ€ì²´ í…ìŠ¤íŠ¸ ìƒì„±
  generateAltText(image) {
    const context = {
      type: image.dataset.type,
      subject: image.dataset.subject,
      action: image.dataset.action,
    };

    return this.formatAltText(context);
  }

  // ëŒ€ì²´ í…ìŠ¤íŠ¸ í¬ë§·íŒ…
  formatAltText(context) {
    const templates = {
      product: `${context.subject} ì œí’ˆ ì´ë¯¸ì§€`,
      banner: `${context.subject} í”„ë¡œëª¨ì…˜ ë°°ë„ˆ`,
      avatar: `${context.subject}ì˜ í”„ë¡œí•„ ì‚¬ì§„`,
    };

    return templates[context.type] || context.subject;
  }

  // í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜
  setupKeyboardNav() {
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && e.target.matches(".zoomable")) {
        this.toggleZoom(e.target);
      }
    });
  }
}
```

### ğŸŒŸ 4ì¥ í•µì‹¬ í¬ì¸íŠ¸

1. **ë¡œë”© ìƒíƒœ**

   - ìŠ¤ì¼ˆë ˆí†¤ UI ì‚¬ìš©
   - ë¶€ë“œëŸ¬ìš´ ì „í™˜ íš¨ê³¼
   - ì—ëŸ¬ ì²˜ë¦¬

2. **ì ì§„ì  ë¡œë”©**

   - ì¸ë„¤ì¼ ë¨¼ì € í‘œì‹œ
   - ê³ í’ˆì§ˆ ì´ë¯¸ì§€ í›„ë¡œë“œ
   - ë¶€ë“œëŸ¬ìš´ ì „í™˜

3. **ì¸í„°ë™ì…˜**

   - ì´ë¯¸ì§€ ì¤Œ ê¸°ëŠ¥
   - ê°¤ëŸ¬ë¦¬ ë„¤ë¹„ê²Œì´ì…˜
   - í‚¤ë³´ë“œ ì§€ì›

4. **ì ‘ê·¼ì„±**
   - ì˜ë¯¸ìˆëŠ” ëŒ€ì²´ í…ìŠ¤íŠ¸
   - í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜
   - ARIA ë ˆì´ë¸”

ë„¤! 5ì¥ "ì´ë¯¸ì§€ ê´€ë¦¬ì™€ ì›Œí¬í”Œë¡œìš°"ë¥¼ ì„¤ëª…í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤! ì´ë¯¸ì§€ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê³  ìë™í™”í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³¼ê²Œìš”.

## ğŸ“š 5ì¥: ì´ë¯¸ì§€ ê´€ë¦¬ì™€ ì›Œí¬í”Œë¡œìš°

#### 1ï¸âƒ£ ì´ë¯¸ì§€ ìë™í™” íŒŒì´í”„ë¼ì¸

```js
class ImagePipeline {
  constructor() {
    this.processors = [];
    this.setupDefaultProcessors();
  }

  // ê¸°ë³¸ í”„ë¡œì„¸ì„œ ì„¤ì •
  setupDefaultProcessors() {
    this.addProcessor({
      name: "resize",
      process: async (image) => {
        const sizes = [300, 600, 900, 1200];
        return Promise.all(sizes.map((size) => this.resize(image, size)));
      },
    });

    this.addProcessor({
      name: "optimize",
      process: async (image) => {
        return this.optimize(image, {
          quality: 85,
          format: "webp",
        });
      },
    });

    this.addProcessor({
      name: "metadata",
      process: async (image) => {
        return this.addMetadata(image, {
          copyright: "Â© 2024",
          lastModified: new Date(),
        });
      },
    });
  }

  // ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹¤í–‰
  async processImage(image) {
    let processed = image;

    for (const processor of this.processors) {
      try {
        processed = await processor.process(processed);
      } catch (error) {
        console.error(`${processor.name} ì²˜ë¦¬ ì‹¤íŒ¨:`, error);
        throw error;
      }
    }

    return processed;
  }
}
```

#### 2ï¸âƒ£ ì´ë¯¸ì§€ ê´€ë¦¬ ì‹œìŠ¤í…œ

```js
class ImageManagementSystem {
  constructor() {
    this.storage = new ImageStorage();
    this.database = new ImageDatabase();
  }

  // ì´ë¯¸ì§€ ì—…ë¡œë“œ ë° ì²˜ë¦¬
  async uploadImage(file, metadata) {
    // ìœ íš¨ì„± ê²€ì‚¬
    this.validateImage(file);

    // ì´ë¯¸ì§€ ì²˜ë¦¬
    const pipeline = new ImagePipeline();
    const processed = await pipeline.processImage(file);

    // ì €ì¥
    const url = await this.storage.store(processed);

    // ë©”íƒ€ë°ì´í„° ì €ì¥
    await this.database.saveMetadata({
      url,
      metadata,
      size: processed.size,
      dimensions: processed.dimensions,
      format: processed.format,
      createdAt: new Date(),
    });

    return url;
  }

  // ì´ë¯¸ì§€ ê²€ìƒ‰
  async searchImages(query) {
    const results = await this.database.search({
      text: query.text,
      tags: query.tags,
      dateRange: query.dateRange,
    });

    return results.map((result) => ({
      ...result,
      url: this.storage.getUrl(result.id),
    }));
  }

  // ì´ë¯¸ì§€ ìµœì í™” ìƒíƒœ ëª¨ë‹ˆí„°ë§
  getOptimizationStats() {
    return {
      totalImages: this.database.count(),
      optimizedCount: this.database.countOptimized(),
      averageSize: this.database.getAverageSize(),
      potentialSavings: this.calculatePotentialSavings(),
    };
  }
}
```

#### 3ï¸âƒ£ ë¹Œë“œ ì‹œìŠ¤í…œ í†µí•©

```js
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif|webp)$/i,
        use: [
          {
            loader: "responsive-loader",
            options: {
              adapter: require("responsive-loader/sharp"),
              sizes: [300, 600, 900, 1200],
              placeholder: true,
              placeholderSize: 40,
              format: "webp",
              quality: 85,
            },
          },
        ],
      },
    ],
  },
  plugins: [
    new ImageMinimizerPlugin({
      minimizerOptions: {
        plugins: [
          ["mozjpeg", { quality: 85 }],
          ["optipng", { optimizationLevel: 5 }],
          ["webp", { quality: 85 }],
        ],
      },
    }),
  ],
};
```

#### 4ï¸âƒ£ CI/CD íŒŒì´í”„ë¼ì¸

```yaml:example/image-cicd.yml
# .github/workflows/image-optimization.yml
name: Image Optimization

on:
  push:
    paths:
      - '**.jpg'
      - '**.png'
      - '**.webp'

jobs:
  optimize:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm install

      - name: Optimize images
        run: |
          npm run optimize-images

      - name: Check optimization results
        run: node scripts/check-image-sizes.js

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "ğŸ—œï¸ Optimize images"
          file_pattern: "**/*.{jpg,png,webp}"
```

### ğŸŒŸ 5ì¥ í•µì‹¬ í¬ì¸íŠ¸

1. **ìë™í™” íŒŒì´í”„ë¼ì¸**

   - ìë™ ë¦¬ì‚¬ì´ì§•
   - í¬ë§· ë³€í™˜
   - ë©”íƒ€ë°ì´í„° ê´€ë¦¬

2. **ê´€ë¦¬ ì‹œìŠ¤í…œ**

   - ì¤‘ì•™ì§‘ì¤‘ì‹ ì €ì¥ì†Œ
   - ë©”íƒ€ë°ì´í„° ê´€ë¦¬
   - ê²€ìƒ‰ ê¸°ëŠ¥

3. **ë¹Œë“œ í†µí•©**

   - ì›¹íŒ© ì„¤ì •
   - ìë™ ìµœì í™”
   - í¬ë§· ë³€í™˜

4. **CI/CD**
   - ìë™ ìµœì í™”
   - í’ˆì§ˆ ì²´í¬
   - ìë™ ì»¤ë°‹

ë„¤! ë§ˆì§€ë§‰ 6ì¥ "ì´ë¯¸ì§€ ë³´ì•ˆê³¼ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§"ì„ ì„¤ëª…í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤! ì´ë¯¸ì§€ë¥¼ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•˜ê³  ì„±ëŠ¥ì„ ì¸¡ì •í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³¼ê²Œìš”.

## ğŸ“š 6ì¥: ì´ë¯¸ì§€ ë³´ì•ˆê³¼ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

#### 1ï¸âƒ£ ì´ë¯¸ì§€ ë³´ì•ˆ

```js
class ImageSecurity {
  constructor() {
    this.allowedFormats = ["jpg", "jpeg", "png", "webp", "avif"];
    this.maxFileSize = 5 * 1024 * 1024; // 5MB
  }

  // ì´ë¯¸ì§€ ìœ íš¨ì„± ê²€ì‚¬
  validateImage(file) {
    // íŒŒì¼ í¬ê¸° ê²€ì‚¬
    if (file.size > this.maxFileSize) {
      throw new Error("íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤");
    }

    // íŒŒì¼ í˜•ì‹ ê²€ì‚¬
    const extension = this.getFileExtension(file.name);
    if (!this.allowedFormats.includes(extension)) {
      throw new Error("ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤");
    }

    // ì´ë¯¸ì§€ ì½˜í…ì¸  ê²€ì‚¬
    return this.scanImageContent(file);
  }

  // ì•ˆì „í•œ URL ìƒì„±
  generateSecureUrl(imageId, options = {}) {
    const timestamp = Date.now();
    const signature = this.generateSignature(imageId, timestamp);

    return {
      url: `/images/${imageId}`,
      token: signature,
      expires: timestamp + 60 * 60 * 1000, // 1ì‹œê°„
    };
  }

  // ì›Œí„°ë§ˆí¬ ì¶”ê°€
  async addWatermark(image, text) {
    return sharp(image)
      .composite([
        {
          input: this.createWatermark(text),
          gravity: "southeast",
        },
      ])
      .toBuffer();
  }
}
```

#### 2ï¸âƒ£ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```js
class ImagePerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.initializeObservers();
  }

  // ì„±ëŠ¥ ê´€ì°°ì ì´ˆê¸°í™”
  initializeObservers() {
    // ì´ë¯¸ì§€ ë¡œë”© ì„±ëŠ¥ ì¸¡ì •
    this.loadObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === "resource" && entry.initiatorType === "img") {
          this.recordMetric(entry);
        }
      }
    });

    // Largest Contentful Paint ì¸¡ì •
    this.lcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.recordLCP(lastEntry);
    });

    this.loadObserver.observe({
      entryTypes: ["resource"],
    });
    this.lcpObserver.observe({
      entryTypes: ["largest-contentful-paint"],
    });
  }

  // ë©”íŠ¸ë¦­ ê¸°ë¡
  recordMetric(entry) {
    const metrics = {
      loadTime: entry.duration,
      size: entry.transferSize,
      protocol: entry.nextHopProtocol,
      cache: entry.transferSize < entry.encodedBodySize ? "HIT" : "MISS",
    };

    this.metrics.set(entry.name, metrics);
  }

  // ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„±
  generateReport() {
    return {
      summary: this.calculateSummary(),
      details: Array.from(this.metrics.entries()),
      recommendations: this.generateRecommendations(),
    };
  }
}
```

#### 3ï¸âƒ£ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

```js
class ImageMonitoringDashboard {
  constructor() {
    this.charts = new Map();
    this.initializeDashboard();
  }

  // ëŒ€ì‹œë³´ë“œ ì´ˆê¸°í™”
  initializeDashboard() {
    // ë¡œë”© ì‹œê°„ ì°¨íŠ¸
    this.charts.set(
      "loadTime",
      new Chart("loadTime", {
        type: "line",
        options: {
          title: "ì´ë¯¸ì§€ ë¡œë”© ì‹œê°„ ì¶”ì´",
          yAxis: { title: "ë¡œë”© ì‹œê°„ (ms)" },
        },
      })
    );

    // ìºì‹œ íˆíŠ¸ìœ¨ ì°¨íŠ¸
    this.charts.set(
      "cacheHitRate",
      new Chart("cacheHit", {
        type: "pie",
        options: {
          title: "ìºì‹œ íˆíŠ¸ìœ¨",
        },
      })
    );

    // í¬ê¸° ë¶„í¬ ì°¨íŠ¸
    this.charts.set(
      "sizeDistribution",
      new Chart("size", {
        type: "histogram",
        options: {
          title: "ì´ë¯¸ì§€ í¬ê¸° ë¶„í¬",
        },
      })
    );
  }

  // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
  updateDashboard(metrics) {
    this.updateLoadTimeChart(metrics.loadTime);
    this.updateCacheHitChart(metrics.cacheHits);
    this.updateSizeDistribution(metrics.sizes);
  }

  // ì•Œë¦¼ ì„¤ì •
  setAlerts(thresholds) {
    this.alerts = {
      loadTime: (threshold) => {
        if (threshold > 3000) {
          // 3ì´ˆ ì´ìƒ
          this.sendAlert("ë¡œë”© ì‹œê°„ì´ ë„ˆë¬´ ê¹ë‹ˆë‹¤");
        }
      },
      size: (threshold) => {
        if (threshold > 1000000) {
          // 1MB ì´ìƒ
          this.sendAlert("ì´ë¯¸ì§€ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤");
        }
      },
    };
  }
}
```

### ğŸŒŸ 6ì¥ í•µì‹¬ í¬ì¸íŠ¸

1. **ë³´ì•ˆ ê´€ë¦¬**

   - íŒŒì¼ ìœ íš¨ì„± ê²€ì‚¬
   - ì•ˆì „í•œ URL ìƒì„±
   - ì›Œí„°ë§ˆí¬ ì¶”ê°€

2. **ì„±ëŠ¥ ì¸¡ì •**

   - ë¡œë”© ì‹œê°„ ì¸¡ì •
   - ìºì‹œ íš¨ìœ¨ì„±
   - LCP ëª¨ë‹ˆí„°ë§

3. **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§**

   - ëŒ€ì‹œë³´ë“œ êµ¬í˜„
   - ì„±ëŠ¥ ì§€í‘œ ì‹œê°í™”
   - ì•Œë¦¼ ì„¤ì •

4. **ìµœì í™” ì¶”ì²œ**
   - ìë™ ë¶„ì„
   - ê°œì„  ì œì•ˆ
   - ìš°ì„ ìˆœìœ„ ì„¤ì •

## ğŸ¯ ë§ˆë¬´ë¦¬!! ì´ë¯¸ì§€ ìµœì í™”ì˜ í•µì‹¬ í¬ì¸íŠ¸

1. **ì˜¬ë°”ë¥¸ ì´ë¯¸ì§€ í¬ë§· ì„ íƒ**

   - JPEG: ì‚¬ì§„ì— ì í•©
   - PNG: íˆ¬ëª…ë„ê°€ í•„ìš”í•  ë•Œ
   - WebP: í˜„ëŒ€ì ì´ê³  íš¨ìœ¨ì 
   - AVIF: ìµœê³ ì˜ ì••ì¶•ë¥ 

2. **ë°˜ì‘í˜• ì´ë¯¸ì§€ í•„ìˆ˜**

   - srcsetê³¼ sizes í™œìš©
   - Picture ì—˜ë¦¬ë¨¼íŠ¸ ì‚¬ìš©
   - ì ì ˆí•œ í¬ê¸° ì œê³µ
   - ì•„íŠ¸ ë””ë ‰ì…˜ ê³ ë ¤

3. **ì„±ëŠ¥ ìµœì í™”**

   - ì´ë¯¸ì§€ ì••ì¶•í•˜ê¸°
   - ì§€ì—° ë¡œë”© ì‚¬ìš©
   - CDN í™œìš©í•˜ê¸°
   - ìºì‹œ ì „ëµ ìˆ˜ë¦½

4. **ìë™í™”ì™€ ê´€ë¦¬**
   - ë¹Œë“œ íŒŒì´í”„ë¼ì¸ êµ¬ì¶•
   - ìë™ ìµœì í™” ë„êµ¬ ì‚¬ìš©
   - ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
   - ë³´ì•ˆ ê´€ë¦¬

ì‰½ê²Œ ë§í•´ì„œ "ì ì ˆí•œ ì´ë¯¸ì§€ë¥¼ ì ì ˆí•œ í¬ê¸°ë¡œ, ì ì ˆí•œ ì‹œì ì— ì œê³µí•˜ì!" ë¼ëŠ” ë§ˆì¸ë“œë¡œ ê°œë°œí•˜ë©´ ë©ë‹ˆë‹¤! ğŸ‘
