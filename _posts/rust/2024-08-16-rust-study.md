---
layout: post
title: "[Rust] study"
subtitle: "Rust 장단점을 파악해보자"

date: 2024-08-16 15:45:00
# lastmod: 2024-08-14 10:10:00
author: "lim.Chuck"

# header-style: text

catalog: true
header-mask: 0.4
header-img: "img/post/0815/1.png"
#
# sitemap:
#   changefreq: daily #스크랩 주기  daily | weekly | monthly
#   priority: 1.0  # 스크랩 우선순위
# hidden: true

tags:
  - rust
  - 러스트
  - 러스트 장점
  - 러스트 단점
---

> 참고문서 <br/>[ 《 Rust_Book 》 ](https://doc.rust-kr.org/)<br/>[ 《 프로그래밍 언어 러스트를 배웁시다! 》 ](https://www.youtube.com/watch?v=W9DO6m8JSSs&list=PLfllocyHVgsSJf1zO6k6o3SX2mbZjAqYE)

## Rust를 공부하기 앞서 주요 특징 알아보자

1. **Garbage Collection 없이 메모리 안전성 제공**:

   - Rust의 가장 두드러진 특징은 가비지 컬렉터 없이도 메모리 안전성을 보장하는 소유권(Ownership) 시스템입니다. 이 시스템은 세 가지 규칙을 기반으로 합니다:
     - Rust의 각 값은 소유자(owner)라고 불리는 변수를 가집니다.
     - 동시에 한 값은 오직 하나의 소유자만 가질 수 있습니다.
     - 소유자가 범위를 벗어나면 그 값은 자동으로 메모리에서 해제됩니다.

2. **제로-코스트 추상화(Zero-Cost Abstraction)**:

   - Rust는 런타임 오버헤드 없이 고수준의 기능과 추상화를 제공하는 것을 목표로 합니다. 이는 표현력이 높으면서도 효율적인 코드를 작성할 수 있음을 의미합니다.

3. **데이터 레이스 없는 동시성**:

   - Rust는 컴파일 타임에 데이터 레이스를 방지하기 위해 동시성 지원 기능을 내장하고 있습니다. 소유권과 빌림(Borrowing) 규칙을 통해 여러 스레드가 동시에 데이터를 수정하는 것을 안전하게 막습니다.

4. **패턴 매칭(Pattern Matching)**:

   - Rust는 강력한 패턴 매칭 기능을 포함하고 있어 복잡한 데이터 구조와 조건을 간결하고 가독성 있게 처리할 수 있습니다.

5. **트레이트(Trait)와 제네릭(Generic)**:

   - Rust의 트레이트는 다른 언어의 인터페이스와 유사하며, 다양한 타입에 걸쳐 공통 동작을 정의할 수 있게 합니다. 또한 제네릭을 지원하여 유연하고 재사용 가능한 코드를 작성할 수 있습니다.

6. **Result와 Option 타입을 활용한 오류 처리**:

   - Rust는 예외(Exception) 대신 `Result`와 `Option` 타입을 사용하여 오류와 선택적 값을 처리합니다. 이는 더 견고하고 명시적인 오류 처리를 장려합니다.

7. **Cargo와 Crates.io**:

   - Cargo는 Rust의 빌드 시스템이자 패키지 관리자로, 종속성 관리, 테스트 실행, 프로젝트 빌드 등을 쉽게 할 수 있습니다. Crates.io는 Rust 라이브러리를 공유하고 다운로드할 수 있는 공개 저장소입니다.

8. **안전하지 않은 코드(Unsafe Code)**:
   - Rust는 안전성을 강조하지만, `unsafe` 키워드를 제공하여 C 코드와의 인터페이스 또는 특정 저수준 작업을 수행할 때 Rust의 안전 검사 일부를 우회할 수 있게 합니다. 하지만 `unsafe` 코드 사용은 엄격히 제어되고 격리됩니다.

### Rust의 장점

1. **메모리 안전성**:

   - Rust의 소유권 모델은 널 포인터 역참조, 댕글링 포인터, 이중 해제와 같은 일반적인 메모리 관련 버그를 방지합니다.

2. **높은 성능**:

   - Rust는 속도를 중시하여 시스템 프로그래밍, 게임 개발, 성능이 중요한 애플리케이션에 적합합니다.

3. **동시성**:

   - Rust의 동시성 접근 방식은 컴파일 타임에 데이터 레이스를 잡아내므로 미묘하고 찾기 어려운 버그의 가능성을 줄입니다.

4. **강력한 타입 시스템**:

   - Rust의 타입 시스템은 트레이트와 제네릭을 포함해 표현력 있고 재사용 가능한 코드를 작성하면서도 많은 오류를 컴파일 타임에 잡아낼 수 있습니다.

5. **성장하는 생태계**:

   - Cargo와 Crates.io 같은 도구 덕분에 Rust는 웹 개발에서 임베디드 시스템에 이르기까지 다양한 응용 프로그램에 점점 더 많이 사용되고 있습니다.

6. **크로스 플랫폼 지원**:
   - Rust는 여러 플랫폼에서 작동하도록 설계되었으며, 네이티브 코드를 컴파일하므로 크로스 플랫폼 개발에 매우 적합합니다.

### Rust의 단점

1. **가파른 학습 곡선**:

   - 특히 소유권 시스템과 같은 Rust의 독특한 기능은 초보자나 유사 개념이 없는 언어에서 Rust로 넘어온 사람들에게 어려움을 줄 수 있습니다.

2. **긴 컴파일 시간**:

   - Rust는 안전성과 제로-코스트 추상화를 강조하기 때문에 대규모 프로젝트의 경우 컴파일 시간이 길어질 수 있습니다.

3. **Unsafe 코드의 복잡성**:

   - `unsafe`는 저수준 프로그래밍을 가능하게 하지만 Rust가 일반적으로 피하는 메모리 안전성 문제를 다시 도입할 위험이 있습니다. `unsafe` 코드를 작성하고 리뷰하는 데는 많은 주의가 필요합니다.

4. **다른 언어에 비해 제한된 라이브러리**:

   - Rust의 생태계가 성장하고 있지만, C++, Python, Java와 같은 더 성숙한 언어에 비해 라이브러리와 프레임워크가 여전히 적습니다.

5. **상대적으로 작은 커뮤니티**:
   - Rust는 빠르게 성장하고 있지만, 여전히 Python이나 JavaScript 같은 언어에 비해 커뮤니티가 작습니다. 이는 특정 문제에 대한 솔루션을 찾거나 Rust 개발자를 채용하는 데 어려움을 줄 수 있습니다.

### 결론

Rust는 성능, 안전성, 현대적인 프로그래밍 기능을 조합한 흥미로운 언어입니다. 메모리 안전성과 동시성이 중요한 시스템 프로그래밍, 임베디드 시스템 등에 특히 적합합니다. 하지만 가파른 학습 곡선과 다른 제약 사항들로 인해, 특히 빠른 개발이나 방대한 라이브러리 생태계가 필요한 프로젝트에서는 최선의 선택이 아닐 수도 있습니다.  
블록체인 공부할때 얼마나 빠른 연산력으로 보다나은 서비스를 공급하는게 문제였나 싶다. 그래서 많은 개발자들이 Rust로 영지식 서킷을 돌리고 하면서 폭발적으로 증가한거같다. 미래 지향적으로 다가 가기 위해 나또한 Rust를 배워 두기로 결심!
